<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Python - Tag - ThnPinkman’s blog</title>
        <link>https://thnpkm.github.io/tags/python/</link>
        <description>Python - Tag - ThnPinkman’s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 20 Aug 2024 23:51:36 &#43;0800</lastBuildDate><atom:link href="https://thnpkm.github.io/tags/python/" rel="self" type="application/rss+xml" /><item>
    <title>Python pth文件写入getshell</title>
    <link>https://thnpkm.github.io/posts/ctf/python-pth%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5getshell/</link>
    <pubDate>Tue, 20 Aug 2024 23:51:36 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://thnpkm.github.io/posts/ctf/python-pth%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5getshell/</guid>
    <description><![CDATA[原理：Python pth文件写入getshell 参考https://www.cnblogs.com/Nestar/p/17336664.html
python的site模块支持&quot;Site-specific configuration hook&quot;的功能，这个功能点本身是用来将特定路径加入模块搜索路径。该模块在初始化期间自动导入
sys.prefix和sys.exec_prefix在D:/Python，那么创建路径为D:\Python\Lib\site-packages\1.pth的pth文件，然后其内容为
D:/Python/temp/ 重新启动python
1.path的路径被添加到sys.path中
site.py的实现中，有这么一段
def addpackage(sitedir, name, known_paths): if known_paths is None: known_paths = _init_pathinfo() reset = True else: reset = False fullname = os.path.join(sitedir, name) _trace(f&#34;Processing .pth file: {fullname!r}&#34;) try: # locale encoding is not ideal especially on Windows. But we have used # it for a long time. setuptools uses the locale encoding too. f = io.TextIOWrapper(io.open_code(fullname), encoding=&#34;locale&#34;) except OSError: return with f: for n, line in enumerate(f): if line.]]></description>
</item>
<item>
    <title>python总结</title>
    <link>https://thnpkm.github.io/posts/ctf/python%E6%80%BB%E7%BB%93/</link>
    <pubDate>Tue, 20 Aug 2024 23:51:36 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://thnpkm.github.io/posts/ctf/python%E6%80%BB%E7%BB%93/</guid>
    <description><![CDATA[任意文件读取(目录穿越) 2022网鼎杯-web669 例题 直接读取文件、参数可控且过滤不全
#以下为部分关键代码，其它部分已省略 #............. @app.route(&#39;/&lt;path:file&gt;&#39;, methods=[&#39;GET&#39;]) def download(file): if session.get(&#39;updir&#39;): basedir = session.get(&#39;updir&#39;) try: path = os.path.join(basedir, file).replace(&#39;../&#39;, &#39;&#39;) if os.path.isfile(path): return send_file(path) else: return response(&#34;Not Found.&#34;, 404) except: return response(&#34;Failed.&#34;, 500) #............. 由于对../的处理只是简单使用replace方法进行替换置空，因此使用双写../（&hellip;.//）即可进行绕过
path = os.path.join(basedir, file).replace(&#39;../&#39;, &#39;&#39;) 然后接下来使用flask的send_file模块读取文件
if os.path.isfile(path): return send_file(path) 实现了任意文件读取
使用open打开文件但未close 配合任意文件读取/proc/self/fd
2020网鼎杯白虎组Web-PicDown app.py源码如下
from flask import Flask, Response from flask import render_template from flask import request import os import urllib app = Flask(__name__) SECRET_FILE = &#34;/tmp/secret.]]></description>
</item>
</channel>
</rss>
